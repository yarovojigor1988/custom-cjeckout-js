"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectAssign = _interopRequireDefault(require("object-assign"));

var _utils = require("../../../common/utils");

var _paymentMethodIdMapper = _interopRequireDefault(require("../../payment-method-mappers/payment-method-id-mapper"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PaymentMapper = /*#__PURE__*/function () {
  _createClass(PaymentMapper, null, [{
    key: "create",

    /**
     * @param {PaymentMethodIdMapper} paymentMethodIdMapper
     * @returns {PaymentMapper}
     */
    value: function create() {
      var paymentMethodIdMapper = _paymentMethodIdMapper.default.create();

      return new PaymentMapper(paymentMethodIdMapper);
    }
    /**
     * @param {PaymentMethodIdMapper} paymentMethodIdMapper
     * @returns {void}
     */

  }]);

  function PaymentMapper(paymentMethodIdMapper) {
    _classCallCheck(this, PaymentMapper);

    /**
     * @private
     * @type {PaymentMethodIdMapper}
     */
    this.paymentMethodIdMapper = paymentMethodIdMapper;
  }
  /**
   * @param {PaymentRequestData} data
   * @returns {Object}
   */


  _createClass(PaymentMapper, [{
    key: "mapToPayment",
    value: function mapToPayment(data) {
      var _data$order = data.order,
          order = _data$order === void 0 ? {} : _data$order,
          _data$orderMeta = data.orderMeta,
          orderMeta = _data$orderMeta === void 0 ? {} : _data$orderMeta,
          _data$payment = data.payment,
          payment = _data$payment === void 0 ? {} : _data$payment,
          _data$paymentMethod = data.paymentMethod,
          paymentMethod = _data$paymentMethod === void 0 ? {} : _data$paymentMethod;
      var payload = {
        device_info: payment.deviceSessionId ? payment.deviceSessionId : null,
        device: orderMeta.deviceFingerprint ? {
          fingerprint_id: orderMeta.deviceFingerprint
        } : null,
        gateway: this.paymentMethodIdMapper.mapToId(paymentMethod),
        notify_url: order.callbackUrl,
        return_url: paymentMethod.returnUrl || (order.payment ? order.payment.returnUrl : null),
        vault_payment_instrument: !payment.instrumentId ? payment.shouldSaveInstrument : null,
        set_as_default_stored_instrument: payment.instrumentId || payment.shouldSaveInstrument ? payment.shouldSetAsDefaultInstrument : null
      };
      var method = paymentMethod.method;

      if (method) {
        (0, _objectAssign.default)(payload, {
          method: method
        });
      }

      var nonce = payment.nonce || paymentMethod.nonce;

      if (payment.formattedPayload) {
        (0, _objectAssign.default)(payload, payment.formattedPayload);
      } else if (payment.instrumentId) {
        (0, _objectAssign.default)(payload, {
          bigpay_token: this.mapToBigPayToken(data)
        });
      } else if (nonce) {
        (0, _objectAssign.default)(payload, {
          credit_card_token: {
            token: nonce
          }
        });
      } else if (payment.cryptogramId) {
        (0, _objectAssign.default)(payload, {
          credit_card_cryptogram: this.mapToCryptogram(data)
        });
      } else {
        (0, _objectAssign.default)(payload, {
          credit_card: this.mapToCreditCard(data)
        });
      }

      return (0, _utils.omitNil)(payload);
    }
    /**
     * @private
     * @param {PaymentRequestData} data
     * @returns {Object}
     */

  }, {
    key: "mapToCreditCard",
    value: function mapToCreditCard(data) {
      var _data$payment2 = data.payment,
          payment = _data$payment2 === void 0 ? {} : _data$payment2;
      return (0, _utils.omitNil)({
        account_name: payment.ccName,
        month: payment.ccExpiry ? (0, _utils.toNumber)(payment.ccExpiry.month) : null,
        number: payment.ccNumber,
        verification_value: payment.ccCvv,
        year: payment.ccExpiry ? (0, _utils.toNumber)(payment.ccExpiry.year) : null,
        customer_code: payment.ccCustomerCode,
        three_d_secure: payment.threeDSecure,
        hosted_form_nonce: payment.hostedFormNonce
      });
    }
    /**
     * @private
     * @param {PaymentRequestData} data
     * @return {Object}
     */

  }, {
    key: "mapToBigPayToken",
    value: function mapToBigPayToken(_ref) {
      var payment = _ref.payment;
      return (0, _utils.omitNil)({
        credit_card_number_confirmation: payment.ccNumber,
        token: payment.instrumentId,
        verification_value: payment.ccCvv,
        verification_nonce: payment.nonce,
        three_d_secure: payment.threeDSecure,
        hosted_form_nonce: payment.hostedFormNonce
      });
    }
    /**
     * @private
     * @param {PaymentRequestData} data
     * @return {Object}
     */

  }, {
    key: "mapToCryptogram",
    value: function mapToCryptogram(_ref2) {
      var payment = _ref2.payment;
      return (0, _utils.omitNil)({
        payment_cryptogram: payment.cryptogramId,
        eci: payment.eci,
        xid: payment.transactionId,
        month: payment.ccExpiry ? (0, _utils.toNumber)(payment.ccExpiry.month) : null,
        number: payment.ccNumber,
        year: payment.ccExpiry ? (0, _utils.toNumber)(payment.ccExpiry.year) : null,
        account_mask: payment.accountMask
      });
    }
  }]);

  return PaymentMapper;
}();

exports.default = PaymentMapper;
//# sourceMappingURL=payment-mapper.js.map