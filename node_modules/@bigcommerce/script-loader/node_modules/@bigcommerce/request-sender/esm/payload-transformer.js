import toFormUrlEncoded from './to-form-url-encoded';
const JSON_CONTENT_TYPE_REGEXP = /application\/(\w+\+)?json/;
const FORM_URLENCODED_CONTENT_TYPE_REGEXP = /application\/x-www-form-urlencoded/;
export default class PayloadTransformer {
    toRequestBody(options) {
        const contentType = options.headers ? this._getHeader(options.headers, 'Content-Type') : '';
        if (options.body) {
            if (JSON_CONTENT_TYPE_REGEXP.test(contentType)) {
                return JSON.stringify(options.body);
            }
            if (FORM_URLENCODED_CONTENT_TYPE_REGEXP.test(contentType)) {
                return toFormUrlEncoded(options.body);
            }
        }
        return options.body;
    }
    toResponse(xhr) {
        const headers = this._parseResponseHeaders(xhr.getAllResponseHeaders());
        const body = this._parseResponseBody('response' in xhr ? xhr.response : xhr.responseText, headers);
        return {
            body,
            headers,
            status: xhr.status,
            statusText: xhr.statusText,
        };
    }
    _parseResponseBody(body, headers) {
        const contentType = this._getHeader(headers, 'Content-Type');
        if (body && JSON_CONTENT_TYPE_REGEXP.test(contentType)) {
            return JSON.parse(body);
        }
        return body;
    }
    _parseResponseHeaders(rawHeaders) {
        const lines = rawHeaders ? rawHeaders.replace(/\r?\n[\t ]+/g, ' ').split(/\r?\n/) : [];
        return lines.reduce((headers, line) => {
            const parts = line.split(':');
            const key = (parts.shift() || '').trim();
            if (!key) {
                return headers;
            }
            return Object.assign(Object.assign({}, headers), { [key.toLowerCase()]: parts.join(':').trim() });
        }, {});
    }
    _getHeader(headers, key) {
        if (!headers || !key) {
            return '';
        }
        return headers[key] || headers[key.toLowerCase()] || '';
    }
}
//# sourceMappingURL=payload-transformer.js.map