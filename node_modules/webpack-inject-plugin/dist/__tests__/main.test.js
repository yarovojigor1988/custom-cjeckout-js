"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var main_1 = require("../main");
describe('injectEntry', function () {
    it('appends to the entry config correctly', function () {
        expect(main_1.injectEntry(undefined, 'foo', {})).toEqual('foo');
        expect(main_1.injectEntry(['original'], 'added', {})).toEqual([
            'added',
            'original'
        ]);
        expect(main_1.injectEntry('original', 'added', {})).toEqual(['added', 'original']);
        expect(main_1.injectEntry(['foo', 'bar'], 'baz', {})).toEqual([
            'foo',
            'baz',
            'bar'
        ]);
        expect(main_1.injectEntry(['foo', 'bar', 'baz', 'blah'], 'aaa', {})).toEqual([
            'foo',
            'bar',
            'baz',
            'aaa',
            'blah'
        ]);
        expect(main_1.injectEntry({
            foo: 'bar',
            another: ['an', 'array']
        }, 'added', {})).toEqual({
            foo: ['added', 'bar'],
            another: ['an', 'added', 'array']
        });
        expect(main_1.injectEntry(function () { return ({ foo: 'bar' }); }, 'added', {})).toEqual({ foo: ['added', 'bar'] });
    });
    it('appends to only the specified entry', function () {
        expect(main_1.injectEntry(undefined, 'foo', { entryName: 'bar' })).toBe('foo');
        expect(main_1.injectEntry({ foo: 'bar', bar: 'baz' }, 'added', { entryName: 'bar' })).toEqual({
            foo: 'bar',
            bar: ['added', 'baz']
        });
    });
    it('supports a filter function', function () {
        expect(main_1.injectEntry({ foo: 'bar', bar: 'baz', baz: 'blah' }, 'added', {
            entryName: function (e) { return e !== 'bar'; }
        })).toEqual({
            foo: ['added', 'bar'],
            bar: 'baz',
            baz: ['added', 'blah']
        });
    });
    it('throws error for unknown filter type', function () {
        expect(function () {
            main_1.injectEntry('bar', 'foo', {
                entryName: { not: 'a function ' }
            });
        }).toThrowError();
    });
    it('respects the config for ordering', function () {
        expect(main_1.injectEntry(['foo', 'bar'], 'baz', { entryOrder: main_1.ENTRY_ORDER.First })).toEqual(['baz', 'foo', 'bar']);
        expect(main_1.injectEntry(['foo', 'bar'], 'baz', { entryOrder: main_1.ENTRY_ORDER.Last })).toEqual(['foo', 'bar', 'baz']);
        expect(main_1.injectEntry(['foo', 'bar'], 'baz', { entryOrder: main_1.ENTRY_ORDER.NotLast })).toEqual(['foo', 'baz', 'bar']);
    });
    it('order config for strings', function () {
        expect(main_1.injectEntry('original', 'new', { entryOrder: main_1.ENTRY_ORDER.First })).toEqual(['new', 'original']);
        expect(main_1.injectEntry('original', 'new', { entryOrder: main_1.ENTRY_ORDER.Last })).toEqual(['original', 'new']);
        expect(main_1.injectEntry('original', 'new', { entryOrder: main_1.ENTRY_ORDER.NotLast })).toEqual(['new', 'original']);
    });
});
//# sourceMappingURL=main.test.js.map